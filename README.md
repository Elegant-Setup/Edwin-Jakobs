![Composition generated by MVBW—1](https://bitbucket.org/edwinlust/mvbw-1/raw/master/images/composition-1.png)

# About

This document describes _MVBW—1_, a computational process that produces compositions that (intentionally) bear some formal resemblances to Mondrian's Victory Boogie Woogie. _MVBW—1_ renders its compositions both on computer screens and to PDF files for print.

_MVBW—1_ (written with an _em-dash_) is written by Edwin Jakobs. 

_MVBW—1_ and some of its products have been entered in the _Elegance_ competition organised by _Setup_. More information about this competition can be found [here](http://elegance.setup.nl).	


# Code

_MVBW—1_ is written in Java 1.6. The code comes with a Maven/Eclipse project.

#### Dependencies

 - Packer (0.0.1), a library (developed by me) around the bin packing algorithm I use in _MVBW—1_. Source can be found at [Packer project page](https://bitbucket.org/edwinlust/packer)
 - Processing (1.5), mostly used for generating PDF files. I added the jar files to the source distribution.

#### Executables

I produced executables for OS X, Windows and Linux for which download links are provided below:

 - [OS X executable](https://bitbucket.org/edwinlust/mvbw-1/downloads/MVBW—1%20OS%20X.zip)
 - [Windows executable (x86)](https://bitbucket.org/edwinlust/mvbw-1/downloads/MVBW—1%20Windows%20x86.zip)
 - [Linux executable (x86)](https://bitbucket.org/edwinlust/mvbw-1/downloads/MVBW—1%20Linux%20x86.zip)

The executable program has a rather minimal user interface that can be used through keyboard only. A listing of the keys is provided below:

 - `x`	— toggle turbo-boost, turbo boost generates 100 rectangles per frame instead of 1
 - `p` — render and write to a timestamped PDF file
 - `t` — toggles debugging mode
 - `r` — reset the canvas and start a new composition


# Process and algorithms

The process that generates the compositions can be broken down into three steps that are repeated until either the canvas is full or the generator is stopped (artist's intervention). 

 1. Sample
 2. Insert
 3. Remove

#### Sample

In the sampling step a single rectangle is generated by sampling from a table that holds templates for rectangles. Each template describes rectangle size, color and a probability. This template table is a product of running the generator many times and manually adjusting the entries until the outcome looks well composed.

#### Insert

In the second step the sampled rectangle is placed on the canvas. For this I use a simple algorithm, for which I will give a basic version. I have little to no idea about the origins of the algorithm.

The algorithm uses a tree structure to maintain an hierarchical organisation of a two dimensional space (the canvas). Every node in the this tree holds:

 - `area` — the rectangular area of the canvas the node covers
 - `children` — a list of references to child nodes that represent subdivisions of the space
 - `item` — a reference to a single item when the space is populated.

Initially this tree structure consists of a single node that represents the full canvas. Placing a rectangular item on the canvas amounts to manipulating the tree structure in the following way (starting at the root node)

	function insert(node, item):
		
		if not isPopulated(node):
			if fits(node, item):
				if hasChildren(node):
					# order the child nodes and iterate over them
					for child in order(node.children):
						container = insert(child, item)
						if container != null:
							return container
						
						return null 		
				else:
					if isPerfectFit(node, item) and isInsideLozenge(node):
						populate(node, item)
						return node
							
					else:
						# split the node and insert into the first child
						# the splitter generates the adviced node first.
						split(node, item)
						return insert(node.children[0])
				
			else:
				# item too large for node
				return null
			
		else:
			# item already populated
			return null
		
		
In this pseudo-code listing I refer to two functions `order()` and `split()` which I would like to give some attention because both functions have great impact on the generated composition. 

The `split()` function splits a node in such a way that a given item will fit perfectly into at least one of the generated child nodes. There are many ways to split nodes, each has its own effect on the final composition. Here is a short overview of splitting strategies I have experimented with.

 - _conservative_ — places the item in the top-left corner of the node's area and splits either vertically or horizontally into 2 child nodes. This strategy deals with the available space in an economic way but does not necessarily result in good compositions.
 - _centered conservative_ — similar to _conservative_ strategy but picks the corner that is closest to the canvas center.
 - _greedy_ — places the item in the center of the node's area and split around the items edges into 9 child nodes. Biases can be introduced to shift the item away from the center.
 - _super greedy_ — similar to the _greedy_ strategy but with added split parameters _n_ and _m_ dividing the node into _(2n+1)(2m+1)_ child nodes

The `order()` function determines the order in which the inserter should try to insert the item in the child nodes. For this generator I have tried two strategies: _as is_ and _random_; The _as is_ strategy takes the order in which `split()` created child nodes. The _random_ strategy permutes the creation order with the result that the composition becomes less predictable.

Before the described sample/insert/remove cycle starts I prepare the canvas by splitting it into a grid of sectors with gutters between them. The grid is given a slight offset such that it does not fall dead in the lozenge shape. In the preparation of the canvas I also place white rectangles in some (according to a simple probabilistic model) of the generated sectors. These white rectangles have to be placed such that they show some visual rhythms or echoes, they cannot be placed freely.

#### Remove

The third step in the process is to remove rectangles that are placed next to at least one rectangle with the same color. This stage makes the final composition more lively as it enforces local variation in color.

Additional removal is performed for blue rectangles. I have had a hard time finding an acceptable layout for blue rectangles since the blue is in such a hard contrast with red and yellow. Eventually I added a rule that blue rectangles must be at least 60 units away from other blue rectangles such that blue is placed evenly over the canvas.

## Optimisations

I have spent some time to optimise the generator in order to generate compositions that are a lot bigger than the original canvas size. I added a simple space partitioning scheme to quickly find neighbouring rectangles. The partitioning scheme divides the canvas up in cells with a fixed size in which rectangles that are added to the canvas are registered. This scheme allows for quick local searches.

Another quick hack to squeeze some extra speed out of the generator is to keep track of the children of the root of the bin packing tree. Inserting rectangles in the rectangle tree is performed by first randomly selecting a child node from a list of available nodes for the given size of rectangle. When insertion fails the child node is removed from the list and will not be used again. This improves performance because the insertion algorithm can currently only find out if the tree is full at the leaf nodes of the rectangle tree. I think this can be improved (although it is still sub-optimal) by keeping track of max(width, height) of the largest free node.

# Analysis

There are strong differences between Mondrian's Victory Boogie Woogie and the compositions that are brought forth by my generator. My generator is built with what I have learned from studying Mondrian's _VBW_, I have never intended to fully mimic his work. The generated compositions are in comparison to Mondrian's composition denser, muddier, less balanced. Or, if we have to look at my compositions as reflecting a city: they hypothesise Mondrian's city's aging.

In a late stage of the process I started wondering what would happen if I change the size of the canvas while keeping the size of the elements (the rectangles) the same. I have generated compositions with up to 400,000 rectangles. Sizing the canvas is an interesting experiment that enables me to see something I have not seen before, however, it is hard to say if changing the size really works for my composition. When I see it on screen I have mixed feelings; I like the added visual complexity but the larger compositions like they miss something, they look a bit too uniform. This may not be an issue when printed on large format. 

![Composition generated by MVBW—1](https://bitbucket.org/edwinlust/mvbw-1/raw/master/images/composition-3.png)

The products of _MVBW—1_ and Mondrian's painting have things in common too. Both Mondrian's _VBW_ and my compositions show multiple scales. There are strong divisions at low scales, that are made in the initial stage of both the painting and my compositions. On top of those divisions smaller divisions are made, and on top of those even smaller ones, and so on. 

In _MVBW—1_ I treat the edges of the canvas differently. For Mondrian the edges work like knives, he stays away from them and only allows large bright areas and small areas to be cut by them. The knives produce non rectangular shapes. For me the edges are like walls, they support whatever I place between them, small rectangles are placed near the edges to fill the last bits of space. In my compositions I decrease the density of rectangles towards the corners of the lozenge to get a similar effect to what Mondrian achieved with the large empty fields.

![Composition generated by MVBW—1](https://bitbucket.org/edwinlust/mvbw-1/raw/master/images/composition-2.png)

Mondrian's work is made in a very strong feedback framework. This is evident from the many revisions to his compositions. He optimized for what he found pleasing to his perception. That is, a perception of an artist who is well trained in looking at things, his own work foremost. _MVBW—1_ is made in a feedback framework too, but instead of getting just a single composition right I attempt to get the computational process that produces an entire family of compositions right.

In _MVBW—1_ I use colors similar to those used by Mondrian. The colors were copied in an early stage of the process of writing my generator, without considering why those specific colors should be used. I played and tweaked the distribution of the colors but never changed the colors themselves until late in the process. When I did change the colors it turned out incredibly hard to accept the changes in appearance, it just looked wrong. 

An interesting difference between Mondrian's _VBW_ and _MVBW—1_ which stems from difference in medium is that Mondrian has encoded —a side-effect, likely— the history of the _VBW_ in the work itself. This self encoding process is what makes _VBW_ a rich work; it is more than just the composition of rectangles, at least to those that care enough to take a closer look. The history of the _VBW_ can be read from its body; there is its unconventional surface and revised choices. In stark contrast: _MVBW—1_ has been on transatlantic flights, hotel rooms, bars and less glorious places and there is no trace of that in what _MVBW—1_ produces or its source code. Every product that comes out of _MVBW-1_ is cleanly stripped from any history, its source code may have some lines of code that I commented out but contains nothing that has the expressive qualities or honesty that the remainders of tape on Mondrian's _VBW_ hold. I need extra devices to tell this story, this document being a very literal — _too_ literal — one at that. I by no means claim that it is not possible to construct computational processes to encode their own history, I just failed to find a sensible way to do so.

# A note on elegance

A central theme in the competition organised by _Setup_ is the elegance of the code and algorithms. I perceive it of very little importance to me, the process of making _MVBW—1_ and the products of _MVBW—1_ that the code is elegant. The code is (subjectively) simple and practically without corner cases or hacks to get things right visually. Actually, I think there is too much abstraction, that my code is too far away from what Mondrian achieved in his Victory Boogie Woogie. There is a pleasing dirtiness on and underneath the surface of that painting, which I fail to reproduce through elegance in code.

